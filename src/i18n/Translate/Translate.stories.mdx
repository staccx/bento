import { Meta, Story, Preview, Props } from '@storybook/addon-docs/blocks';
import { withi18n } from "../../../.storybook/decorators/i18n-decorator"
import Translate from './Translate';
import Heading from "../../components/Text/Heading/Heading"

<Meta title="i18n/Translate" component={Translate} decorators={[ withi18n ]}/>

# Translate
This is a utility component to translate text

It will not return a component, only a value (unless the content is blocks)

```javascript
import { Translate } from "@staccx/bento"
```

export const Test = () => {
     console.log("Translate", Translate.propTypes)
     return <div>Some text</div>
}

# Test
<Story name="test">
<Test />
</Story>

## Translate, no key
When you dont insert a key, it will render what you sent as children. This is useful when you first start adding text to your app, as you can later find all `<Translate />` and add keys to them
<Preview>
  <Story name="No key">
   <Translate>Fallback</Translate>
  </Story>
</Preview>

## Translate, with key
<Preview>
  <Story name="With key">
   <Translate i18n="key">Fallback</Translate>
  </Story>
</Preview>

## Wrapper by an `<h/>` tag
<Preview>
  <Story name="Wrapper by a <h> tag">
  <Heading>
   <Translate i18n="key">Fallback</Translate>
   </Heading>
  </Story>
</Preview>

## Rich text
<Preview>
  <Story name="Rich text">
   <Translate i18n="blocks" data={{balance: 100000}}>Fallback</Translate>
  </Story>
</Preview>

## Arrays
You can send an arrays for getting more keys at the same time
<Preview>
  <Story name="Arrays">
   <Translate i18n={["key", "key2"]}>Fallback</Translate>
  </Story>
</Preview>

but then it makes more sense to use the renderFunction

<Preview>
  <Story name="Arrays properly">
    <ul>
     <Translate i18n={["key", "key2"]}>
       {(result) => result.map(val =>
       (
       <li key={val}>{val}</li>
       ))}
     </Translate>
   </ul>
  </Story>
</Preview>

## Interpolate
 You can inline interpolate values, which is mad handy
 <Preview>
   <Story name="Interpolate">
    <Translate i18n="interpolate" data={{balance: 1000000}}>Fallback</Translate>
   </Story>
 </Preview>

you can even write your own formatFunctions and feed it to the Provider


## Context
 Not to be mistaken with React context, context in i18n is just a way of telling different things of same type from each other.

 <Preview>
   <Story name="Context">
     <div>
        <div>
          <Translate i18n="account">No context</Translate>
        </div>
        <div>
          <Translate i18n="account" data={{context: "savings"}}>Savings</Translate>
        </div>
        <div>
          <Translate i18n="account" data={{context: "funds"}}>Funds</Translate>
        </div>
        <div>
          <Translate i18n="account" data={{context: "usage"}}>Usage</Translate>
        </div>
      </div>
   </Story>
 </Preview>

you can even write your own formatFunctions and feed it to the Provider

## Pluralisation
Pluralisation is used when you need to pluralize something. Your data needs to have a `{key}_plural` entry in order for this to work.
<Preview>
  <Story name="Pluralisation">
    <div>
      <div>
       <Translate i18n="car" data={{count: 0}} />
      </div>
     <div>
       <Translate i18n="car" data={{count: 1}} />
       </div>
      <div>
       <Translate i18n="car" data={{count: 7}} />
       </div>
     </div>
  </Story>
</Preview>

## Props for Translate
<Props of={Translate} />
